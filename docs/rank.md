# 排序算法概述
所谓推荐系统中的排序，是指对于召回的候选集中的item，根据其属性，并结合用户画像以及上下文信息，计算出匹配程度的得分。items之间的得分高低就反映了它们不同的呈现优先级，等同于进行了排序。

从点击率预估的角度理解，Rank就是预测给定user和上下文情况下，每个item的点击率。

## 排序算法的输入和输出
从上面的描述可知，排序算法的输入是召回的候选集+上下文信息+用户画像，输出是给候选集中的每个item赋予的打分。召回的候选集无须赘述，上下文信息是指app用户进入特定页面，发起推荐请求时所携带的动态信息，比如时间、地理位置、页面类型、请求的item类型等；用户画像是指用户的静态信息例如年龄、性别、职业等，以及用户的行为统计特征例如历史点击浏览记录、购买记录等。上下文信息是动态和瞬时的，实时获取，并在实时计算中使用；而用户画像是相对静态和稳定的，通常是预先离线跑spark任务计算好并放入数据库（是召回算法的工作的一部分），以便排序时实时查询。

## 排序算法的架构
与主要以离线方式运行的召回算法不同，排序算法基本是实时的。在实际应用当中，排序算法通常作为一个服务（Rank as a Service）供推荐系统调用。Rank Service的核心是打分函数，打分函数可以根据召回候选集+上下文信息+用户画像，对每一个item打分。打分函数可以由人工规则制定，也可以是机器学习学出来的。如果是前者，Rank Service直接调用打分函数对每个item打分；如果是后者，Rank Service会调用预先离线训练好的model对每个item打分。

在实际的推荐系统中，排序通常有不止一轮。以常见的三轮排序为例，分别是：
>* 第一轮粗排序，主要目的是对输入的候选集进行筛选，控制进入主排序的item数目。粗排序处理的item数量通常比较大，因此往往采用一些简单的规则进行排序筛选。粗排序的例子比如LBS相关应用中，根据用户的地理位置，把10公里之外的商户先过滤掉，只保留用户附近的商户。
>* 第二轮主排序，是最核心的排序算法，很大程度上决定了最终返回结果。主排序的得分函数通常是机器学习的方式训练得到的，即后面会讲到的Learning to Rank。
>* 第三轮针对topN进行精细排序和调整。在移动互联网的时代，用户在第一屏没看到自己感兴趣的内容，有可能就直接退出app，因此一个推荐系统的成败很大程度上取决于前30条甚至前10条推荐。因此在最终返回给用户前，根据用户画像和上下文信息，对topN的item进行精细Re-Rank，逐渐成了业界普遍采用的做法。

## 传统排序算法--规则排序

## Learning to Rank

根据模型不同，常见的L2R可以分为LR(Logistic Regression)，gbdt，LR与gbdt的组合，以及深度学习模型等
### LR
### gbdt
### LR+gbdt
### 深度学习模型

根据损失函数定义方式的不同，L2R可以分为三类：Pointwise方法，Pairwise方法，Listwise方法
### Pointwise

### Pairwise

### Listwise
