# 推荐算法概述

推荐系统整体上可以分为前端和后端两大部分。前端包括App或网页上呈献给用户的推荐位、推荐条目信息，以及对用户点击浏览行为的埋点记录；后端包括推荐算法和推荐效果评估。前端和后端会形成闭环：推荐算法->app上对用户呈现->用户行为的记录和反馈->推荐效果评估->改进推荐算法。

本文重点讲述推荐系统后端当中的推荐算法环节。

从功能角度，推荐算法可以分为两大部分：召回(Recall)和排序（Rank）。所谓召回，是指从item全集中筛选出推荐候选集；而排序则是指对候选集中的每一个item进行匹配度打分，将items按照匹配度得分进行降序排列。

在十年前，人们对于推荐算法的研究侧重于召回算法。常见的召回算法有协同过滤、隐因子模型、基于图的召回算法等等。近十年随着手机成为最主要的信息传播媒介，同时不同应用之间的竞争也愈发激烈，为了进一步挖掘推荐系统的性能，业界对排序算法的关注和研究在逐渐增加。

下面分别从召回和排序两个方面介绍推荐算法。

## 常用的召回算法

### UserCF 
即基于User的协同过滤（Collaborative Filtering）。UserCF的思路是向目标用户推荐跟他兴趣相似的用户所喜欢的item。所以UserCF通常包含两个过程：
#### 1.找到跟目标用户兴趣相似的用户集合
#### 2.找到该集合中的用户喜欢的，而目标用户尚未接触过的item并推荐给目标用户

用户之间的similarity是通过用户的行为统计得到的。这里的行为指的是用户对item的点击、浏览、购买、评分等行为（通常点击、浏览被称为隐性行为，这类行为携带的信息量小，但由于发生频率高，数据量大，因而也具有统计价值；购买、评分被称为显性行为，这类行为更直接反映了用户喜好，但是发生频次较低，数据规模较小）。这里有一个基于点击行为计算用户similarity的例子：
>* 有两个用户user1和user2，他们各自点击过的item集合分别是S1和S2，那么user1和user2的similarity可以定义为S1和S2交集的模除以S1和S2并集的模。

similarity的定义可以有多种方式，上例采用的是Jaccard公式形式，除此之外还可以采用Cosine similarity，Pearson similarity等等。

user CF的计算方式如下（以点击行为为例）：
>* 注：一个user对一个item的点击行为按bool值计算，true代表点击过（无论点击了多少次），false代表没点击过
>* 假设有m个user，n个item，总点击数为N，即每个item平均被N/n个user点击过，每个user平均点击了N/m个item
>* 首先要得到字典形式的item-user关系表dict={item:users}，dict的key是每一个item，value是点击过这个item的所有user的列表
>* 然后遍历item-user关系表求得user-user相似度矩阵U。矩阵U为m * m维，U每一个元素Uij代表第user-i和user-j共同点击过的item总个数
>* 计算字典形式的user-item关系表dict={user:items}，dict的key是每一个user，value是这个user点击过的所有item的列表
>* 得到U和user-item关系表之后，就可以方便的求出任意目标user的相似user集合，然后推荐这个集合当中的user所点击过的item给目标user
>* 从上可以看出，要想给一个user做推荐需要先计算得到user-user相似度矩阵U和user-item关系表。建矩阵和关系表的时间复杂度都为O(N)，空间复杂度分别为O(m * m)和O(N)
