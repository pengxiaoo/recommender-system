# recommender-system

推荐系统的目标是向user推荐他可能感兴趣的item。在早期，推荐问题常常被看做评分预测问题，即已知user对一组item的评分，预测他对一个新的item的评分。著名的netflix竞赛就是属于这种类型。近年来工业界推荐系统更侧重于topN推荐，即向user推荐他最可能感兴趣的N个items。topN推荐在实际生活中的应用更广泛，本文所针对的都是topN推荐。

推荐系统整体上可以分为前端和后端两大部分。前端包括App或网页上呈献给用户的推荐位、推荐条目信息，以及对用户点击浏览行为的埋点记录；后端包括推荐算法和推荐效果评估。前端和后端会形成闭环：推荐算法->app上对用户呈现->用户行为的记录和反馈->推荐效果评估->改进推荐算法。

从功能角度，推荐算法可以分为两大部分：召回(Recall)和排序（Rank）。所谓召回，是指从item全集中筛选出推荐候选集；而排序则是指对候选集中的每一个item进行匹配度打分，将items按照匹配度得分进行降序排列。召回通常是离线跑批方式运行，而排序通常需要针对用户请求进行实时响应。

在十年前，人们对于推荐算法的研究侧重于召回算法。常见的召回算法有协同过滤、隐因子模型、基于图的召回算法等等。关于召回算法的研究资料比较丰富，其中值得推荐的入门资料是项亮的《推荐系统实践》一书。近年来随着手机成为最主要的信息传播媒介，同时不同应用之间的竞争愈发激烈，人们对推荐系统提出了更高的要求。为了进一步挖掘推荐系统的性能，业界对排序算法的关注和研究在逐渐增加。

下面分别从召回和排序两个方面介绍推荐算法。

## [常用的召回算法][1]
召回算法有很多，除了上述提到的几种之外，还有基于用户调研的召回，基于社交网络的召回（例如”你的好友XXX也买了这本书“）等等。不过本质上与前面介绍的召回算法并没有太大差异，这里不再单独细述。如以基于社交网络的召回为例，其主要过程是建立和查询user->friend映射表以及friend->item映射表，与content-based推荐很类似。

召回算法的主体部分通常是以离线方式运行分布式任务（例如spark）来完成的。一个典型的spark任务通常包含：
>* 读取业务数据库和log数据库，进行数据预处理
>* 生成user画像和item特征、user和item之间的关系，有时甚至直接生成候选集
>* 对生成好的特征和候选集建立索引，写入数据库（如redis）

对于离线生成的特征如何高效的建立索引，是召回算法至关重要的一环，索引的查询性能直接影响了后续排序算法的耗时。索引通常分两大类：一类是B树，这也是大多数数据库内建的索引方式，对于结构化、半结构化的数据非常有效；另一类是基于近似最近邻的哈希算法（Hashing-based ANN），对于非结构化的数据例如文本、图片非常有效。基于近似最近邻的哈希算法的具体实现根据数据的类型不同而不同，例如geo信息可以通过GeoHash、文本可以通过SimHash、图片可以通过CNN bottleneck layer的encoding并结合LSH(Locality Sensitive Hashing)来实现。

在工业界实际应用中，很少单独采用一种或两种召回算法，通常采用多种召回算法并行的架构，每种召回算法独立运行产生召回结果，最后merge起来然后喂给Rank模块。

## [排序算法概述][2]

[1]: https://github.com/pengxiaoo/recommender-system/blob/master/docs/recall.md
[2]: https://github.com/pengxiaoo/recommender-system/blob/master/docs/rank.md
